// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE

import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as EloRank from "elo-rank";
import * as Belt_List from "bs-platform/lib/es6/belt_List.js";
import * as Belt_Array from "bs-platform/lib/es6/belt_Array.js";
import * as Caml_int32 from "bs-platform/lib/es6/caml_int32.js";
import * as Belt_MapString from "bs-platform/lib/es6/belt_MapString.js";
import * as Belt_SortArray from "bs-platform/lib/es6/belt_SortArray.js";
import * as Caml_primitive from "bs-platform/lib/es6/caml_primitive.js";
import * as Utils$Coronate from "./Utils.bs.js";

function isNotDummy(scoreDict, oppId) {
  var match = Belt_MapString.get(scoreDict, oppId);
  if (match !== undefined) {
    return !match[/* isDummy */3];
  } else {
    return true;
  }
}

function getPlayerScore(scoreDict, id) {
  var match = Belt_MapString.get(scoreDict, id);
  if (match !== undefined) {
    return Utils$Coronate.listSumF(match[/* results */7]);
  } else {
    return 0.0;
  }
}

function getOpponentScores(scoreDict, id) {
  var match = Belt_MapString.get(scoreDict, id);
  if (match !== undefined) {
    return Belt_MapString.keysToArray(match[/* opponentResults */4]).filter((function (param) {
                    return isNotDummy(scoreDict, param);
                  })).map((function (param) {
                  return getPlayerScore(scoreDict, param);
                }));
  } else {
    return /* array */[];
  }
}

function getMedianScore(scoreDict, id) {
  return Utils$Coronate.$$Array[/* sumF */2](Belt_SortArray.stableSortBy(getOpponentScores(scoreDict, id), Caml_obj.caml_compare).slice(1, -1));
}

function getSolkoffScore(scoreDict, id) {
  return Utils$Coronate.$$Array[/* sumF */2](getOpponentScores(scoreDict, id));
}

function runningReducer(acc, score) {
  var lastScore = acc ? acc[0] : 0.0;
  return /* :: */[
          lastScore + score,
          acc
        ];
}

function getCumulativeScore(scoreDict, id) {
  var match = Belt_MapString.get(scoreDict, id);
  if (match !== undefined) {
    return Utils$Coronate.listSumF(Belt_List.reduce(match[/* resultsNoByes */8], /* [] */0, runningReducer));
  } else {
    return 0.0;
  }
}

function getCumulativeOfOpponentScore(scoreDict, id) {
  var match = Belt_MapString.get(scoreDict, id);
  if (match !== undefined) {
    return Utils$Coronate.$$Array[/* sumF */2](Belt_MapString.keysToArray(match[/* opponentResults */4]).filter((function (param) {
                        return isNotDummy(scoreDict, param);
                      })).map((function (param) {
                      return getCumulativeScore(scoreDict, param);
                    })));
  } else {
    return 0.0;
  }
}

function getColorBalanceScore(scoreDict, id) {
  var match = Belt_MapString.get(scoreDict, id);
  if (match !== undefined) {
    return Utils$Coronate.listSumF(match[/* colorScores */0]);
  } else {
    return 0.0;
  }
}

var tieBreakMethods = /* array */[
  /* record */[
    /* func */getMedianScore,
    /* id */0,
    /* name */"Median"
  ],
  /* record */[
    /* func */getSolkoffScore,
    /* id */1,
    /* name */"Solkoff"
  ],
  /* record */[
    /* func */getCumulativeScore,
    /* id */2,
    /* name */"Cumulative score"
  ],
  /* record */[
    /* func */getCumulativeOfOpponentScore,
    /* id */3,
    /* name */"Cumulative of opposition"
  ],
  /* record */[
    /* func */getColorBalanceScore,
    /* id */4,
    /* name */"Most black"
  ]
];

function getNamefromIndex(index) {
  return Belt_Array.getExn(tieBreakMethods, index)[/* name */2];
}

function getTieBreakNames(idList) {
  return idList.map(getNamefromIndex);
}

function createBlankScoreData(id) {
  return /* record */[
          /* colorScores : [] */0,
          /* colors : [] */0,
          /* id */id,
          /* isDummy */false,
          /* opponentResults */Belt_MapString.empty,
          /* ratings : [] */0,
          /* firstRating */0,
          /* results : [] */0,
          /* resultsNoByes : [] */0
        ];
}

function standingsSorter(a, b) {
  var result = 0;
  var tieBreakIndex = 0;
  var $$break = false;
  while(result === 0 && !$$break) {
    var x = Caml_primitive.caml_float_compare(b[/* score */1], a[/* score */1]);
    if (x !== 0) {
      result = x;
    } else {
      var match = Belt_Array.get(b[/* tieBreaks */2], tieBreakIndex);
      var match$1 = Belt_Array.get(a[/* tieBreaks */2], tieBreakIndex);
      if (match !== undefined && match$1 !== undefined) {
        var x$1 = Caml_primitive.caml_float_compare(match, match$1);
        if (x$1 !== 0) {
          result = x$1;
        } else {
          tieBreakIndex = tieBreakIndex + 1 | 0;
        }
      } else {
        $$break = true;
      }
    }
  };
  return result;
}

function createStandingList(methods, scoreData) {
  var selectedTieBreakFuncs = methods.map((function (i) {
          return Belt_Array.getExn(tieBreakMethods, i)[/* func */0];
        }));
  var standings = Belt_MapString.keysToArray(scoreData).map((function (id) {
          return /* record */[
                  /* id */id,
                  /* score */getPlayerScore(scoreData, id),
                  /* tieBreaks */selectedTieBreakFuncs.map((function (func) {
                          return Curry._2(func, scoreData, id);
                        }))
                ];
        }));
  return Belt_SortArray.stableSortBy(standings, standingsSorter);
}

function areScoresEqual(standing1, standing2) {
  var equalScores = standing1[/* score */1] !== standing2[/* score */1];
  if (equalScores) {
    return false;
  } else {
    return !standing1[/* tieBreaks */2].reduce((function (acc, value, i) {
                    return /* array */[value !== Belt_Array.getExn(standing2[/* tieBreaks */2], i)].concat(acc);
                  }), /* array */[]).includes(true);
  }
}

function createStandingTree(standingList) {
  return standingList.reduce((function (acc, standing, i) {
                var match = i === 0;
                var isNewRank = match ? true : !areScoresEqual(standing, Belt_Array.getExn(standingList, i - 1 | 0));
                if (isNewRank) {
                  return acc.concat(/* array */[/* array */[standing]]);
                } else {
                  var lastIndex = acc.length - 1 | 0;
                  Belt_Array.set(acc, lastIndex, Belt_Array.getExn(acc, lastIndex).concat(/* array */[standing]));
                  return acc;
                }
              }), /* array */[]);
}

function getKFactor(matchCount) {
  var match = matchCount > 0;
  var ne = match ? matchCount : 1;
  return Caml_int32.div(800, ne);
}

function keepAboveFloor(rating) {
  var match = rating > 100;
  if (match) {
    return rating;
  } else {
    return 100;
  }
}

function calcNewRatings(param, param$1, param$2) {
  var blackRating = param[1];
  var whiteRating = param[0];
  var whiteElo = new EloRank.default(getKFactor(param$1[0]));
  var blackElo = new EloRank.default(getKFactor(param$1[1]));
  var whiteScoreExpected = whiteElo.getExpected(whiteRating, blackRating);
  var blackScoreExpected = blackElo.getExpected(blackRating, whiteRating);
  return /* tuple */[
          keepAboveFloor(whiteElo.updateRating(whiteScoreExpected, param$2[0], whiteRating)),
          keepAboveFloor(blackElo.updateRating(blackScoreExpected, param$2[1], blackRating))
        ];
}

var Ratings = /* module */[
  /* getKFactor */getKFactor,
  /* floor */100,
  /* keepAboveFloor */keepAboveFloor,
  /* EloRank */0,
  /* calcNewRatings */calcNewRatings
];

export {
  isNotDummy ,
  getPlayerScore ,
  getOpponentScores ,
  getMedianScore ,
  getSolkoffScore ,
  runningReducer ,
  getCumulativeScore ,
  getCumulativeOfOpponentScore ,
  getColorBalanceScore ,
  tieBreakMethods ,
  getNamefromIndex ,
  getTieBreakNames ,
  createBlankScoreData ,
  standingsSorter ,
  createStandingList ,
  areScoresEqual ,
  createStandingTree ,
  Ratings ,
  
}
/* elo-rank Not a pure module */
