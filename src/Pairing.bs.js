// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE

import * as Belt_List from "bs-platform/lib/es6/belt_List.js";
import * as Belt_Array from "bs-platform/lib/es6/belt_Array.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Belt_MapString from "bs-platform/lib/es6/belt_MapString.js";
import * as Belt_SortArray from "bs-platform/lib/es6/belt_SortArray.js";
import * as Caml_primitive from "bs-platform/lib/es6/caml_primitive.js";
import * as Utils$Coronate from "./Utils.bs.js";
import * as EdmondsBlossom from "edmonds-blossom";

function priority(value, condition) {
  if (condition) {
    return value;
  } else {
    return 0.0;
  }
}

function divisiblePriority(dividend, divisor) {
  return dividend / divisor;
}

function avoidMeetingTwice(param) {
  if (param) {
    return 32.0;
  } else {
    return 0.0;
  }
}

function sameScores(param) {
  return 16.0 / param;
}

function halfPosition(param) {
  return 8.0 / param;
}

function sameHalfPriority(param) {
  return 0.0;
}

function differentHalf(isDiffHalf) {
  if (isDiffHalf) {
    return halfPosition;
  } else {
    return sameHalfPriority;
  }
}

function differentDueColor(param) {
  if (param) {
    return 4.0;
  } else {
    return 0.0;
  }
}

var maxPriority = Utils$Coronate.$$Array[/* sumF */2](/* array */[
      halfPosition(1.0),
      4.0,
      16.0 / 1.0,
      32.0
    ]);

function calcPairIdeal(player1, player2) {
  if (player1[/* id */0] === player2[/* id */0]) {
    return 0.0;
  } else {
    var metBefore = Belt_List.has(player1[/* opponents */6], player2[/* id */0], (function (prim, prim$1) {
            return prim === prim$1;
          }));
    var mustAvoid = Belt_List.has(player1[/* avoidIds */1], player2[/* id */0], (function (prim, prim$1) {
            return prim === prim$1;
          }));
    var match = player1[/* colors */3];
    var isDiffDueColor;
    if (match) {
      var match$1 = player2[/* colors */3];
      isDiffDueColor = match$1 ? match[0] !== match$1[0] : true;
    } else {
      isDiffDueColor = true;
    }
    var scoreDiff = Utils$Coronate.absf(player1[/* score */8] - player2[/* score */8]) + 1.0;
    var halfDiff = Pervasives.abs(player1[/* halfPos */4] - player2[/* halfPos */4] | 0) + 1 | 0;
    var isDiffHalf = player1[/* isUpperHalf */5] !== player2[/* isUpperHalf */5] && player1[/* score */8] === player2[/* score */8];
    return Utils$Coronate.$$Array[/* sumF */2](/* array */[
                isDiffDueColor ? 4.0 : 0.0,
                16.0 / scoreDiff,
                (
                    isDiffHalf ? halfPosition : sameHalfPriority
                  )(halfDiff),
                !metBefore && !mustAvoid ? 32.0 : 0.0
              ]);
  }
}

function descendingScore(param, param$1) {
  return Utils$Coronate.descend((function (x) {
                return x[/* score */8];
              }), param, param$1);
}

function descendingRating(param, param$1) {
  return Utils$Coronate.descend((function (x) {
                return x[/* rating */7];
              }), param, param$1);
}

function splitInHalf(arr) {
  var midpoint = arr.length / 2 | 0;
  return /* tuple */[
          Belt_Array.slice(arr, 0, midpoint),
          Belt_Array.sliceToEnd(arr, midpoint)
        ];
}

function setUpperHalves(data) {
  var dataList = Belt_MapString.valuesToArray(data);
  return Belt_Array.reduce(dataList, Belt_MapString.empty, (function (acc, playerData) {
                var match = splitInHalf(Belt_SortArray.stableSortBy(dataList.filter((function (p2) {
                                  return p2[/* score */8] === playerData[/* score */8];
                                })), descendingRating).map((function (p) {
                            return p[/* id */0];
                          })));
                var upperHalfIds = match[0];
                var isUpperHalf = upperHalfIds.includes(playerData[/* id */0]);
                var halfPos = isUpperHalf ? upperHalfIds.indexOf(playerData[/* id */0]) : match[1].indexOf(playerData[/* id */0]);
                var newPlayerData_000 = /* id */playerData[/* id */0];
                var newPlayerData_001 = /* avoidIds */playerData[/* avoidIds */1];
                var newPlayerData_002 = /* colorScores */playerData[/* colorScores */2];
                var newPlayerData_003 = /* colors */playerData[/* colors */3];
                var newPlayerData_006 = /* opponents */playerData[/* opponents */6];
                var newPlayerData_007 = /* rating */playerData[/* rating */7];
                var newPlayerData_008 = /* score */playerData[/* score */8];
                var newPlayerData = /* record */[
                  newPlayerData_000,
                  newPlayerData_001,
                  newPlayerData_002,
                  newPlayerData_003,
                  /* halfPos */halfPos,
                  /* isUpperHalf */isUpperHalf,
                  newPlayerData_006,
                  newPlayerData_007,
                  newPlayerData_008
                ];
                return Belt_MapString.set(acc, playerData[/* id */0], newPlayerData);
              }));
}

function sortByScoreThenRating(data1, data2) {
  var x = Caml_primitive.caml_float_compare(data1[/* score */8], data2[/* score */8]);
  if (x !== 0) {
    return x;
  } else {
    return Caml_primitive.caml_int_compare(data1[/* rating */7], data2[/* rating */7]);
  }
}

function setByePlayer(byeQueue, dummyId, data) {
  var hasNotHadBye = function (p) {
    return !Belt_List.has(p[/* opponents */6], dummyId, (function (prim, prim$1) {
                  return prim === prim$1;
                }));
  };
  var match = Belt_MapString.keysToArray(data).length % 2 === 0;
  if (match) {
    return /* tuple */[
            data,
            undefined
          ];
  } else {
    var dataList = Belt_List.sort(Belt_List.keep(Belt_List.fromArray(Belt_MapString.valuesToArray(data)), hasNotHadBye), sortByScoreThenRating);
    var playerIdsWithoutByes = Belt_List.map(dataList, (function (p) {
            return p[/* id */0];
          }));
    var hasntHadByeFn = function (id) {
      return Belt_List.has(playerIdsWithoutByes, id, (function (prim, prim$1) {
                    return prim === prim$1;
                  }));
    };
    var nextByeSignups = Belt_List.keep(Belt_List.fromArray(byeQueue), hasntHadByeFn);
    var dataForNextBye;
    if (nextByeSignups) {
      var match$1 = Belt_MapString.get(data, nextByeSignups[0]);
      dataForNextBye = match$1 !== undefined ? match$1 : Belt_List.getExn(dataList, 0);
    } else {
      dataForNextBye = dataList ? dataList[0] : Belt_List.getExn(Belt_List.sort(Belt_List.fromArray(Belt_MapString.valuesToArray(data)), sortByScoreThenRating), 0);
    }
    var dataWithoutBye = Belt_MapString.remove(data, dataForNextBye[/* id */0]);
    return /* tuple */[
            dataWithoutBye,
            dataForNextBye
          ];
  }
}

function assignColorsForPair(pair) {
  var player2 = pair[1];
  var player1 = pair[0];
  var match = Utils$Coronate.listSumF(player1[/* colorScores */2]) < Utils$Coronate.listSumF(player2[/* colorScores */2]);
  if (match) {
    return /* tuple */[
            player2[/* id */0],
            player1[/* id */0]
          ];
  } else {
    return /* tuple */[
            player1[/* id */0],
            player2[/* id */0]
          ];
  }
}

function netScore(param) {
  return param[0][/* score */8] + param[1][/* score */8];
}

function netRating(param) {
  return param[0][/* rating */7] + param[1][/* rating */7];
}

function sortByNetScoreThenRating(pair1, pair2) {
  var x = Caml_primitive.caml_float_compare(netScore(pair2), netScore(pair1));
  if (x !== 0) {
    return x;
  } else {
    return Caml_primitive.caml_float_compare(netRating(pair2), netRating(pair1));
  }
}

function pairPlayers(pairData) {
  var playerIdArray = Belt_MapString.keysToArray(pairData);
  var playerArray = Belt_MapString.valuesToArray(pairData);
  var pairIdealReducer = function (accArr, player1, index) {
    var playerMatches = playerArray.slice(index + 1 | 0, Infinity).map((function (player2) {
            return /* tuple */[
                    playerIdArray.indexOf(player1[/* id */0]),
                    playerIdArray.indexOf(player2[/* id */0]),
                    calcPairIdeal(player1, player2)
                  ];
          }));
    return accArr.concat(playerMatches);
  };
  var blossom2Pairs = function (acc, p1Index, p2Index) {
    var match = p1Index === -1;
    if (match) {
      return acc;
    } else {
      var p1 = Belt_MapString.getExn(pairData, Belt_Array.getExn(playerIdArray, p1Index));
      var p2 = Belt_MapString.getExn(pairData, Belt_Array.getExn(playerIdArray, p2Index));
      var matched = acc.map((function (param) {
              return param[0];
            }));
      var match$1 = !matched.includes(p1) && !matched.includes(p2);
      if (match$1) {
        return acc.concat(/* array */[/* tuple */[
                      p1,
                      p2
                    ]]);
      } else {
        return acc;
      }
    }
  };
  return EdmondsBlossom.default(playerArray.reduce(pairIdealReducer, /* array */[])).reduce(blossom2Pairs, /* array */[]).sort(sortByNetScoreThenRating).map(assignColorsForPair);
}

export {
  priority ,
  divisiblePriority ,
  avoidMeetingTwice ,
  sameScores ,
  halfPosition ,
  sameHalfPriority ,
  differentHalf ,
  differentDueColor ,
  maxPriority ,
  calcPairIdeal ,
  descendingScore ,
  descendingRating ,
  splitInHalf ,
  setUpperHalves ,
  sortByScoreThenRating ,
  setByePlayer ,
  assignColorsForPair ,
  netScore ,
  netRating ,
  sortByNetScoreThenRating ,
  pairPlayers ,
  
}
/* maxPriority Not a pure module */
