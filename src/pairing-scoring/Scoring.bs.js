// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE

import * as Ramda from "ramda";
import * as Js_dict from "bs-platform/lib/es6/js_dict.js";
import * as Caml_array from "bs-platform/lib/es6/caml_array.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";

function add(a, b) {
  return a + b | 0;
}

function arraySum(arr) {
  return arr.reduce(add, 0);
}

function addFloat(a, b) {
  return a + b;
}

function arraySumFloat(arr) {
  return arr.reduce(addFloat, 0.0);
}

function last(arr) {
  return Caml_array.caml_array_get(arr, arr.length - 1 | 0);
}

function isNotDummy(scoreDict, oppId) {
  var opponent = Js_dict.get(scoreDict, oppId);
  if (opponent !== undefined) {
    return !Caml_option.valFromOption(opponent).isDummy;
  } else {
    return true;
  }
}

function getPlayerScore(scoreDict, id) {
  var player = Js_dict.get(scoreDict, id);
  if (player !== undefined) {
    return arraySumFloat(Caml_option.valFromOption(player).results);
  } else {
    return 0.0;
  }
}

function getOpponentScores(scoreDict, id) {
  var player = Js_dict.get(scoreDict, id);
  if (player !== undefined) {
    return Object.keys(Caml_option.valFromOption(player).opponentResults).filter((function (param) {
                    return isNotDummy(scoreDict, param);
                  })).map((function (param) {
                  return getPlayerScore(scoreDict, param);
                }));
  } else {
    return /* array */[];
  }
}

function getMedianScore(scoreDict, id) {
  return arraySumFloat(Ramda.sort((function (param, param$1) {
                      return Ramda.ascend((function (x) {
                                    return x;
                                  }), param, param$1);
                    }), getOpponentScores(scoreDict, id)).slice(1, -1));
}

function getSolkoffScore(scoreDict, id) {
  return arraySumFloat(getOpponentScores(scoreDict, id));
}

function runningReducer(acc, score) {
  return acc.concat(/* array */[last(acc) + score]);
}

function getCumulativeScore(scoreDict, id) {
  var person = Js_dict.get(scoreDict, id);
  if (person !== undefined) {
    return arraySumFloat(Caml_option.valFromOption(person).resultsNoByes.reduce(runningReducer, /* array */[0.0]));
  } else {
    return 0.0;
  }
}

function getCumulativeOfOpponentScore(scoreDict, id) {
  var person = Js_dict.get(scoreDict, id);
  if (person !== undefined) {
    return arraySumFloat(Object.keys(Caml_option.valFromOption(person).opponentResults).filter((function (param) {
                        return isNotDummy(scoreDict, param);
                      })).map((function (param) {
                      return getCumulativeScore(scoreDict, param);
                    })));
  } else {
    return 0.0;
  }
}

function getColorBalanceScore(scoreDict, id) {
  var person = Js_dict.get(scoreDict, id);
  if (person !== undefined) {
    return arraySumFloat(Caml_option.valFromOption(person).colorScores);
  } else {
    return 0.0;
  }
}

var tieBreakMethods = /* array */[
  {
    func: getMedianScore,
    id: 0,
    name: "Median"
  },
  {
    func: getSolkoffScore,
    id: 1,
    name: "Solkoff"
  },
  {
    func: getCumulativeScore,
    id: 2,
    name: "Cumulative score"
  },
  {
    func: getCumulativeOfOpponentScore,
    id: 3,
    name: "Cumulative of opposition"
  },
  {
    func: getColorBalanceScore,
    id: 4,
    name: "Most black"
  }
];

function getNamefromIndex(index) {
  return Caml_array.caml_array_get(tieBreakMethods, index).name;
}

function getTieBreakNames(idList) {
  return idList.map(getNamefromIndex);
}

export {
  add ,
  arraySum ,
  addFloat ,
  arraySumFloat ,
  last ,
  isNotDummy ,
  getPlayerScore ,
  getOpponentScores ,
  getMedianScore ,
  getSolkoffScore ,
  runningReducer ,
  getCumulativeScore ,
  getCumulativeOfOpponentScore ,
  getColorBalanceScore ,
  tieBreakMethods ,
  getNamefromIndex ,
  getTieBreakNames ,
  
}
/* ramda Not a pure module */
