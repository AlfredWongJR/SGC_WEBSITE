// Generated by BUCKLESCRIPT VERSION 6.0.3, PLEASE EDIT WITH CARE

import * as Js_dict from "bs-platform/lib/es6/js_dict.js";
import * as Belt_Array from "bs-platform/lib/es6/belt_Array.js";
import * as Caml_array from "bs-platform/lib/es6/caml_array.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Belt_MapString from "bs-platform/lib/es6/belt_MapString.js";

var dummy_id = "________DUMMY________";

function isNanoId(str) {
  return (/^[A-Za-z0-9_-]{21}$/).test(str);
}

function isDummyId(playerId) {
  return playerId === dummy_id;
}

var dummyPlayer = {
  firstName: "Bye",
  id: dummy_id,
  lastName: "Player",
  matchCount: 0,
  rating: 0,
  type_: "dummy"
};

function makeMissingPlayer(id) {
  return {
          firstName: "Anonymous",
          id: id,
          lastName: "Player",
          matchCount: 0,
          rating: 0,
          type_: "missing"
        };
}

function getPlayerMaybe(playerDict, id) {
  var match = id === dummy_id;
  if (match) {
    return dummyPlayer;
  } else {
    var match$1 = Js_dict.get(playerDict, id);
    if (match$1 !== undefined) {
      return Caml_option.valFromOption(match$1);
    } else {
      return makeMissingPlayer(id);
    }
  }
}

function getPlayerMaybeMap(playerMap, id) {
  var match = id === dummy_id;
  if (match) {
    return dummyPlayer;
  } else {
    return Belt_MapString.getWithDefault(playerMap, id, makeMissingPlayer(id));
  }
}

var Player = /* module */[
  /* isDummyId */isDummyId,
  /* dummyPlayer */dummyPlayer,
  /* makeMissingPlayer */makeMissingPlayer,
  /* getPlayerMaybe */getPlayerMaybe,
  /* getPlayerMaybeMap */getPlayerMaybeMap
];

var Match = /* module */[];

var Tournament = /* module */[];

var defaultOptions = {
  avoidPairs: /* array */[],
  byeValue: 1.0,
  lastBackup: new Date(0.0)
};

function rounds2Matches(roundList, lastRound, param) {
  var rounds = lastRound !== undefined ? (function (param) {
            return (function (param$1) {
                return roundList.slice(param, param$1);
              });
          })(0)(lastRound + 1 | 0) : roundList;
  return rounds.reduce((function (acc, round) {
                return acc.concat(round);
              }), /* array */[]);
}

function getUnmatched(roundList, players, roundId) {
  var match = Belt_Array.get(roundList, roundId);
  var matchList = match !== undefined ? match : /* array */[];
  var matchedIds = matchList.reduce((function (acc, match_) {
          return acc.concat(/* array */[
                      match_.playerIds.whiteId,
                      match_.playerIds.blackId
                    ]);
        }), /* array */[]);
  var unmatched = { };
  Js_dict.values(players).forEach((function (player) {
          if (matchedIds.includes(player.id)) {
            return 0;
          } else {
            unmatched[player.id] = player;
            return /* () */0;
          }
        }));
  return unmatched;
}

function isRoundComplete(roundList, players, roundId) {
  var match = roundId < (roundList.length - 1 | 0);
  if (match) {
    return true;
  } else {
    var unmatched = getUnmatched(roundList, players, roundId);
    var results = Caml_array.caml_array_get(roundList, roundId).map((function (match_) {
            return match_.result.whiteScore + match_.result.blackScore;
          }));
    if (Object.keys(unmatched).length === 0) {
      return !results.includes(0.0);
    } else {
      return false;
    }
  }
}

var win = 1.0;

var loss = 0.0;

var draw = 0.5;

export {
  win ,
  loss ,
  draw ,
  dummy_id ,
  isNanoId ,
  Player ,
  Match ,
  Tournament ,
  defaultOptions ,
  rounds2Matches ,
  getUnmatched ,
  isRoundComplete ,
  
}
/* defaultOptions Not a pure module */
