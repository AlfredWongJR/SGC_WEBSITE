// Generated by BUCKLESCRIPT VERSION 6.0.3, PLEASE EDIT WITH CARE

import * as Js_dict from "bs-platform/lib/es6/js_dict.js";
import * as Belt_Array from "bs-platform/lib/es6/belt_Array.js";
import * as Caml_array from "bs-platform/lib/es6/caml_array.js";

function colorToJs(param) {
  return param + 0 | 0;
}

function colorFromJs(param) {
  if (param <= 1 && 0 <= param) {
    return param - 0 | 0;
  }
  
}

var dummy_id = "________DUMMY________";

function isNanoId(str) {
  return (/^[A-Za-z0-9_-]{21}$/).test(str);
}

function playerToJs(param) {
  return {
          firstName: param[/* firstName */0],
          id: param[/* id */1],
          lastName: param[/* lastName */2],
          matchCount: param[/* matchCount */3],
          rating: param[/* rating */4],
          type_: param[/* type_ */5]
        };
}

function playerFromJs(param) {
  return /* record */[
          /* firstName */param.firstName,
          /* id */param.id,
          /* lastName */param.lastName,
          /* matchCount */param.matchCount,
          /* rating */param.rating,
          /* type_ */param.type_
        ];
}

function matchToJs(param) {
  return {
          id: param[/* id */0],
          newRating: param[/* newRating */1],
          origRating: param[/* origRating */2],
          playerIds: param[/* playerIds */3],
          result: param[/* result */4]
        };
}

function matchFromJs(param) {
  return /* record */[
          /* id */param.id,
          /* newRating */param.newRating,
          /* origRating */param.origRating,
          /* playerIds */param.playerIds,
          /* result */param.result
        ];
}

function tournamentToJs(param) {
  return {
          byeQueue: param[/* byeQueue */0],
          date: param[/* date */1],
          id: param[/* id */2],
          name: param[/* name */3],
          playerIds: param[/* playerIds */4],
          roundList: param[/* roundList */5],
          tieBreaks: param[/* tieBreaks */6]
        };
}

function tournamentFromJs(param) {
  return /* record */[
          /* byeQueue */param.byeQueue,
          /* date */param.date,
          /* id */param.id,
          /* name */param.name,
          /* playerIds */param.playerIds,
          /* roundList */param.roundList,
          /* tieBreaks */param.tieBreaks
        ];
}

function isDummyId(playerId) {
  return playerId === dummy_id;
}

var dummyPlayer = /* record */[
  /* firstName */"Bye",
  /* id */dummy_id,
  /* lastName */"Player",
  /* matchCount */0,
  /* rating */0,
  /* type_ */"dummy"
];

function makeMissingPlayer(id) {
  return /* record */[
          /* firstName */"Anonymous",
          /* id */id,
          /* lastName */"Player",
          /* matchCount */0,
          /* rating */0,
          /* type_ */"missing"
        ];
}

function getPlayerMaybe(playerDict, id) {
  var match = id === dummy_id;
  if (match) {
    return dummyPlayer;
  } else {
    var match$1 = Js_dict.get(playerDict, id);
    if (match$1 !== undefined) {
      return match$1;
    } else {
      return makeMissingPlayer(id);
    }
  }
}

function rounds2Matches(roundList, lastRound, param) {
  var rounds = lastRound !== undefined ? (function (param) {
            return (function (param$1) {
                return roundList.slice(param, param$1);
              });
          })(0)(lastRound + 1 | 0) : roundList;
  return rounds.reduce((function (acc, round) {
                return acc.concat(round);
              }), /* array */[]);
}

function getUnmatched(roundList, players, roundId) {
  var match = Belt_Array.get(roundList, roundId);
  var matchList = match !== undefined ? match : /* array */[];
  var matchedIds = matchList.reduce((function (acc, match_) {
          return acc.concat(/* array */[
                      match_[/* playerIds */3][/* whiteId */0],
                      match_[/* playerIds */3][/* blackId */1]
                    ]);
        }), /* array */[]);
  var unmatched = { };
  Js_dict.values(players).forEach((function (player) {
          if (matchedIds.includes(player[/* id */2])) {
            return 0;
          } else {
            unmatched[player[/* id */2]] = player;
            return /* () */0;
          }
        }));
  return unmatched;
}

function isRoundComplete(roundList, players, roundId) {
  var match = roundId < (roundList.length - 1 | 0);
  if (match) {
    return true;
  } else {
    var unmatched = getUnmatched(roundList, players, roundId);
    var results = Caml_array.caml_array_get(roundList, roundId).map((function (match_) {
            return match_[/* result */4][/* whiteScore */0] + match_[/* result */4][/* blackScore */1];
          }));
    if (Object.keys(unmatched).length === 0) {
      return !results.includes(0.0);
    } else {
      return false;
    }
  }
}

var white = 0;

var black = 1;

var win = 1.0;

var loss = 0.0;

var draw = 0.5;

export {
  colorToJs ,
  colorFromJs ,
  white ,
  black ,
  win ,
  loss ,
  draw ,
  dummy_id ,
  isNanoId ,
  playerToJs ,
  playerFromJs ,
  matchToJs ,
  matchFromJs ,
  tournamentToJs ,
  tournamentFromJs ,
  isDummyId ,
  dummyPlayer ,
  makeMissingPlayer ,
  getPlayerMaybe ,
  rounds2Matches ,
  getUnmatched ,
  isRoundComplete ,
  
}
/* No side effect */
