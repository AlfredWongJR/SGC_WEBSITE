// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE

import * as Curry from "bs-platform/lib/es6/curry.js";
import * as React from "react";
import * as Belt_Set from "bs-platform/lib/es6/belt_Set.js";
import * as Belt_List from "bs-platform/lib/es6/belt_List.js";
import * as Belt_MapString from "bs-platform/lib/es6/belt_MapString.js";
import * as DemoData$Coronate from "../../DemoData.bs.js";
import * as TestData$Coronate from "../../TestData.bs.js";
import * as Data_Player$Coronate from "../../Data/Data_Player.bs.js";
import * as Data_Rounds$Coronate from "../../Data/Data_Rounds.bs.js";

function log2(num) {
  return Math.log(num) / Math.log(2.0);
}

var configData_000 = /* avoidPairs */Belt_Set.mergeMany(TestData$Coronate.config[/* avoidPairs */0], Belt_Set.toArray(DemoData$Coronate.config[/* avoidPairs */0]));

var configData_001 = /* byeValue */TestData$Coronate.config[/* byeValue */1];

var configData_002 = /* lastBackup */TestData$Coronate.config[/* lastBackup */2];

var configData = /* record */[
  configData_000,
  configData_001,
  configData_002
];

var tournamentData = Belt_MapString.merge(TestData$Coronate.tournaments, DemoData$Coronate.tournaments, (function (param, param$1, a) {
        return a;
      }));

var playerData = Belt_MapString.merge(TestData$Coronate.players, DemoData$Coronate.players, (function (param, param$1, a) {
        return a;
      }));

function calcNumOfRounds(playerCount) {
  var roundCount = Math.ceil(log2(playerCount));
  var match = roundCount !== Number.NEGATIVE_INFINITY;
  if (match) {
    return roundCount | 0;
  } else {
    return 0;
  }
}

function tournamentReducer(param, action) {
  return action;
}

function playersReducer(state, action) {
  switch (action.tag | 0) {
    case 0 : 
        return Belt_MapString.set(state, action[0], action[1]);
    case 1 : 
        return Belt_MapString.remove(state, action[0]);
    case 2 : 
        return action[0];
    
  }
}

function LoadTournament_mock(Props) {
  var children = Props.children;
  var tourneyId = Props.tourneyId;
  var match = React.useReducer(tournamentReducer, Belt_MapString.getExn(tournamentData, tourneyId));
  var tourney = match[0];
  var playerIds = tourney[/* playerIds */4];
  var roundList = tourney[/* roundList */5];
  var match$1 = React.useReducer(playersReducer, Belt_MapString.keep(playerData, (function (id, param) {
              return Belt_List.has(tourney[/* playerIds */4], id, (function (prim, prim$1) {
                            return prim === prim$1;
                          }));
            })));
  var players = match$1[0];
  var getPlayer = function (param) {
    return Data_Player$Coronate.getPlayerMaybe(players, param);
  };
  var activePlayers = Belt_MapString.keep(players, (function (id, param) {
          return Belt_List.has(playerIds, id, (function (prim, prim$1) {
                        return prim === prim$1;
                      }));
        }));
  var roundCount = calcNumOfRounds(Belt_MapString.size(activePlayers));
  var isItOver = roundList.length >= roundCount;
  var match$2 = roundList.length === 0;
  var isNewRoundReady = match$2 ? true : Data_Rounds$Coronate.isRoundComplete(roundList, activePlayers, roundList.length - 1 | 0);
  return Curry._1(children, /* record */[
              /* activePlayers */activePlayers,
              /* getPlayer */getPlayer,
              /* isItOver */isItOver,
              /* isNewRoundReady */isNewRoundReady,
              /* players */players,
              /* playersDispatch */match$1[1],
              /* roundCount */roundCount,
              /* tourney */tourney,
              /* setTourney */match[1]
            ]);
}

var make = LoadTournament_mock;

export {
  log2 ,
  configData ,
  tournamentData ,
  playerData ,
  calcNumOfRounds ,
  tournamentReducer ,
  playersReducer ,
  make ,
  
}
/* configData Not a pure module */
