// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Curry from "bs-platform/lib/es6/curry.js";
import * as React from "react";
import * as Belt_Set from "bs-platform/lib/es6/belt_Set.js";
import * as Belt_List from "bs-platform/lib/es6/belt_List.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Db$Coronate from "../../Db.bs.js";
import * as Belt_MapString from "bs-platform/lib/es6/belt_MapString.js";
import * as DemoData$Coronate from "../../DemoData.bs.js";
import * as TestData$Coronate from "../../TestData.bs.js";
import * as Data_Player$Coronate from "../../Data/Data_Player.bs.js";
import * as Data_Rounds$Coronate from "../../Data/Data_Rounds.bs.js";

function log2(num) {
  return Math.log(num) / Math.log(2.0);
}

var configData_avoidPairs = Belt_Set.mergeMany(TestData$Coronate.config.avoidPairs, Belt_Set.toArray(DemoData$Coronate.config.avoidPairs));

var configData_byeValue = TestData$Coronate.config.byeValue;

var configData_lastBackup = TestData$Coronate.config.lastBackup;

var configData = {
  avoidPairs: configData_avoidPairs,
  byeValue: configData_byeValue,
  lastBackup: configData_lastBackup
};

function merger(_key, a, b) {
  if (a !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(a));
  } else if (b !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(b));
  } else {
    return ;
  }
}

var tournamentData = Belt_MapString.merge(TestData$Coronate.tournaments, DemoData$Coronate.tournaments, merger);

var playerData = Belt_MapString.merge(TestData$Coronate.players, DemoData$Coronate.players, merger);

function calcNumOfRounds(playerCount) {
  var roundCount = Math.ceil(log2(playerCount));
  var match = roundCount !== Pervasives.neg_infinity;
  if (match) {
    return roundCount | 0;
  } else {
    return 0;
  }
}

function tournamentReducer(param, action) {
  return action;
}

function LoadTournament_mock(Props) {
  var children = Props.children;
  var tourneyId = Props.tourneyId;
  var match = React.useReducer(tournamentReducer, Belt_MapString.getExn(tournamentData, tourneyId));
  var tourney = match[0];
  var roundList = tourney.roundList;
  var playerIds = tourney.playerIds;
  var match$1 = Db$Coronate.useAllPlayers(/* () */0);
  var players = match$1[0];
  var activePlayers = Belt_MapString.keep(players, (function (id, param) {
          return Belt_List.has(playerIds, id, (function (prim, prim$1) {
                        return prim === prim$1;
                      }));
        }));
  var roundCount = calcNumOfRounds(Belt_MapString.size(activePlayers));
  var isItOver = Data_Rounds$Coronate.size(roundList) >= roundCount;
  var match$2 = Data_Rounds$Coronate.size(roundList) === 0;
  var isNewRoundReady = match$2 ? true : Data_Rounds$Coronate.isRoundComplete(roundList, activePlayers, Data_Rounds$Coronate.size(roundList) - 1 | 0);
  return Curry._1(children, {
              activePlayers: activePlayers,
              getPlayer: (function (param) {
                  return Data_Player$Coronate.getPlayerMaybe(players, param);
                }),
              isItOver: isItOver,
              isNewRoundReady: isNewRoundReady,
              players: players,
              playersDispatch: match$1[1],
              roundCount: roundCount,
              tourney: tourney,
              setTourney: match[1]
            });
}

var make = LoadTournament_mock;

export {
  log2 ,
  configData ,
  merger ,
  tournamentData ,
  playerData ,
  calcNumOfRounds ,
  tournamentReducer ,
  make ,
  
}
/* configData Not a pure module */
