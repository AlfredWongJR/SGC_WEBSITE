{"version":3,"sources":["chess-tourney/constants.js","chess-tourney/player.js","jsx/utility.jsx","chess-tourney/scores.js","chess-tourney/pairing.js","chess-tourney/match.js","jsx/tournament.jsx","jsx/players.jsx","jsx/options.jsx","App.jsx","serviceWorker.js","index.jsx"],"names":["BLACK","WHITE","createPlayer","importObj","arguments","length","undefined","id","firstName","lastName","rating","matchCount","Object","freeze","dummyPlayer","getPlayer","playerList","filter","p","getPlayerAvoidList","playerId","avoidList","pair","includes","reduce","accumulator","concat","cleanAvoidList","ids","map","pairs","kFactor","calcNewRatings","origRatings","matchCounts","result","whiteElo","EloRank","blackElo","scoreExpected","getExpected","updateRating","Button","_ref","children","action","react_default","a","createElement","onClick","BackButton","_ref2","OpenButton","_ref3","Panel","_ref5","style","objectSpread","PanelContainer","_ref6","display","React","Children","child","isBye","match","players","playerMatchColor","matchList","color","m","indexOf","getMatchesByPlayer","roundList","roundId","slice","acc","round","hasHadBye","getPlayersByOpponent","opponentId","playerScore","score","scoreList","playerScoreList","b","playerScoreCum","runningScore","cumScores","playerScoreListNoByes","forEach","push","totalScore","playerColorBalance","modifiedMedian","solkoff","scores","opponent","sort","pop","shift","finalScore","tbMethods","name","func","oppScores","calcStandings","methods","tieBreaks","standingsFlat","allPlayers","Array","from","Set","getAllPlayers","pId","method","sortFunc","firstBy","standing","ignore","index","thenBy","standingsTree","runningRank","i","orig","standing1","standing2","areEqual","areScoresEqual","getPlayerMatchData","roundNum","data","opponents","colorBalance","genPlayerData","dueColor","opponentHistory","upperHalf","avoidMeetingTwicePriority","sameScoresPriority","differentHalfPriority","differentDueColorPriority","calcPairIdeal","player1","player2","scoreDiff","priority","metBefore","mustAvoid","Math","abs","ceil","byeMatch","potentialMatches","matches","reducedResults","playerData","byePlayerData","last","playersWithScore","pd","reverse","chunk","playerDatum","src","playerMatches","player","blossom","p1Id","p2Id","p1","p2","ideal","matched","origRating","newRating","TournamentList","setPlayerList","tourneyList","setTourneyList","_useState","useState","_useState2","slicedToArray","openTourney","setOpenTourney","content","react","TournamentTabs","tourneyId","backButton","tourney","key","_useState3","_useState4","defaultTab","setDefaultTab","_calcStandings","_calcStandings2","standingTree","autoPair","unPairedPlayers","pairPlayers","createMatch","toConsumableArray","manualPair","setMatchResult","matchId","white","black","_calcNewRatings","_calcNewRatings2","whiteRating","blackRating","prevTourney","newTourney","es","defaultIndex","standings","rank","className","Round","num","_useState5","_useState6","selectedMatch","setSelectedMatch","_useState7","_useState8","selectedPlayers","setSelectedPlayers","selectPlayer","event","Number","target","value","checked","prevState","unMatched","pos","type","onChange","PlayerMatchInfo","disabled","_ref4","prettyBalance","numeral","format","PlayerView","setAvoidList","openPlayer","setOpenPlayer","PlayerInfoBox","PlayerList","newPlayerDefault","newPlayerData","setNewPlayerdata","nextId","setNextId","updateField","preventDefault","update","currentTarget","assign","rosterTable","splice","delPlayer","onSubmit","newPlayer","prevId","required","singAvoidList","setSingAvoidList","unAvoided","_useState9","_useState10","selectedAvoider","setSelectedAvoider","useEffect","avoidPlayer","avoidAdd","onBlur","Options","JSON","stringify","outputPlayers","setOutputPlayers","outputTourney","setOutputTourney","rows","cols","Caution","role","aria-label","href","Boolean","window","location","hostname","ReactDOM","render","demoRoster","demoTourneyList","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.017e2474.chunk.js","sourcesContent":["// @ts-check\nconst BLACK = 1;\nexport {BLACK};\nconst WHITE = 0;\nexport {WHITE};","// @ts-check\nimport EloRank from \"elo-rank\";\nimport {WHITE, BLACK} from \"./constants\";\n/**\n * @typedef {import(\"./index\").Player} Player\n * @typedef {import(\"./index\").MatchScore} MatchScore\n */\n\nfunction createPlayer(importObj = {}) {\n    /** @type {Player} */\n    const player = {\n        id: importObj.id || 0,\n        firstName: importObj.firstName || \"\",\n        lastName: importObj.lastName || \"\",\n        rating: importObj.rating || 0,\n        matchCount: importObj.matchCount || 0\n    };\n    return player;\n}\nexport default Object.freeze(createPlayer);\n\nconst dummyPlayer = createPlayer();\ndummyPlayer.id = -1;\ndummyPlayer.firstName = \"Bye\";\nObject.freeze(dummyPlayer);\nexport {dummyPlayer};\n\n\n/**\n * @param {number} id\n * @param {Player[]} playerList\n */\nfunction getPlayer(id, playerList) {\n    if (id === -1) {\n        return dummyPlayer;\n    }\n    return playerList.filter((p) => p.id === id)[0];\n}\nObject.freeze(getPlayer);\nexport {getPlayer};\n\n/**\n * @param {number} playerId\n * @param {number[][]} avoidList\n * @returns {number[]}\n */\nfunction getPlayerAvoidList(playerId, avoidList) {\n    return avoidList.filter( // get pairings with the player\n        (pair) => pair.includes(playerId)\n    ).reduce( // Flatten the array\n        (accumulator, pair) => pair.concat(accumulator),\n        []\n    ).filter( // filter out the player's id\n        (id) => id !== playerId\n    );\n}\nObject.freeze(getPlayerAvoidList);\nexport {getPlayerAvoidList};\n\n/**\n * @param {number[][]} avoidList\n * @param {Player[]} playerList\n */\nfunction cleanAvoidList(avoidList, playerList) {\n    const ids = playerList.map((p) => p.id);\n    return avoidList.filter(\n        (pairs) => (ids.includes(pairs[0]) && ids.includes(pairs[1]))\n    );\n}\nObject.freeze(cleanAvoidList);\nexport {cleanAvoidList};\n\n/**\n * @param {number} matchCount\n */\nfunction kFactor(matchCount) {\n    const ne = matchCount || 1;\n    return (800 / ne);\n}\nObject.freeze(kFactor);\nexport {kFactor};\n\n/**\n * @param {[number, number]} origRatings\n * @param {[number, number]} matchCounts\n * @param {[MatchScore, MatchScore]} result\n */\nfunction calcNewRatings(origRatings, matchCounts, result) {\n    const whiteElo = new EloRank(kFactor(matchCounts[WHITE]));\n    const blackElo = new EloRank(kFactor(matchCounts[BLACK]));\n    const FLOOR = 100;\n    const scoreExpected = [\n        whiteElo.getExpected(origRatings[WHITE], origRatings[BLACK]),\n        blackElo.getExpected(origRatings[BLACK], origRatings[WHITE])\n    ];\n    const newRating = [\n        whiteElo.updateRating(\n            scoreExpected[WHITE],\n            result[WHITE],\n            origRatings[WHITE]\n        ),\n        blackElo.updateRating(\n            scoreExpected[BLACK],\n            result[BLACK],\n            origRatings[BLACK]\n        )\n    ];\n    return newRating.map(\n        (rating) => (\n            (rating < FLOOR)\n            ? FLOOR\n            : rating\n        )\n    );\n}\nObject.freeze(calcNewRatings);\nexport {calcNewRatings};","// @ts-check\nimport React from \"react\";\nimport {FaArrowsAltV} from \"react-icons/fa\";\n\n/**\n * @param {Object} props\n * @param {JSX.Element | string} [props.children]\n * @param {(event: React.MouseEvent | React.KeyboardEvent) => void} props.action\n */\nexport function Button({children, action}\n) {\n    return (\n        <nav>\n            <button onClick={action}>\n                {children}\n            </button>\n        </nav>\n    );\n}\n\n/**\n * @param {Object} props\n * @param {(event: React.MouseEvent | React.KeyboardEvent) => void} props.action\n */\nexport function BackButton({action}) {\n    return <Button action={action}>&lt; Back</Button>;\n}\n\n/**\n * @param {Object} props\n * @param {(event: React.MouseEvent | React.KeyboardEvent) => void} props.action\n */\nexport function OpenButton({action}) {\n    return <Button action={action}>Open &gt;</Button>;\n}\n\n/**\n * @param {Object} props\n * @param {boolean} props.isDragged\n */\nexport function DragIcon({isDragged}) {\n    return (\n        <FaArrowsAltV style={{cursor: isDragged ? 'grabbing' : 'grab'}}\n        tabIndex={-1}/>\n    );\n\n}\n\n/**\n * @param {*[]} arr\n * @param {number} pos\n * @param {number} dir\n */\nexport function moveArrItem(arr, pos, dir) {\n    const newPos = pos + dir;\n    const newArr = [...arr];\n    const movedMethod = newArr.splice(pos, 1)[0];\n    newArr.splice(newPos, 0, movedMethod);\n    return newArr;\n}\n\n/**\n * @param {object} props\n * @param {React.ReactNode} props.children\n * @param {React.CSSProperties} [props.style]\n */\nexport function Panel({children, style}) {\n    return (\n        <div style={{...style}}>\n            {children}\n        </div>\n    );\n}\n\n/**\n *\n * @param {object} props\n */\nexport function PanelContainer({children}) {\n    return (\n        <div style={{display: \"flex\"}}>\n            {React.Children.map(children, (child) => child)}\n        </div>\n    );\n}","// @ts-check\nimport {firstBy} from \"thenby\";\nimport {dummyPlayer, getPlayer, getPlayerAvoidList} from \"./player\";\n\n/**\n * @typedef {import(\"./index\").ScoreCalculator} ScoreCalculator\n * @typedef {import(\"./index\").Match} Match\n */\n\n/**\n *\n * @param {Match} match\n * @returns {boolean}\n */\nfunction isBye(match) {\n    return match.players.includes(dummyPlayer.id);\n}\n\n/**\n * @param {number} playerId\n * @param {object[]} matchList\n * @returns {number?}\n */\nfunction playerMatchColor(playerId, matchList) {\n    /**@type {number} */\n    let color = null;\n    const match = matchList.filter((m) => m.players.includes(playerId))[0];\n    if (match) {\n        color = match.players.indexOf(playerId);\n    }\n    return color;\n}\nObject.freeze(playerMatchColor);\nexport {playerMatchColor};\n\n/**\n * @type {ScoreCalculator}\n * @returns {Match[]}\n */\nfunction getMatchesByPlayer(playerId, roundList, roundId = null) {\n    let rounds;\n    if (roundId === null) {\n        rounds = roundList;\n    } else {\n        rounds = roundList.slice(0, roundId + 1);\n    }\n    return rounds.reduce( // flatten the rounds to just the matches\n        (acc, round) => acc.concat(round),\n        []\n    ).filter(\n        (match) => match.players.includes(playerId)\n    );\n}\n\n/**\n * @type {ScoreCalculator}\n * @returns {boolean}\n */\nfunction hasHadBye(playerId, roundList, roundId = null) {\n    return getMatchesByPlayer(\n        playerId,\n        roundList,\n        roundId\n    ).reduce(\n        (acc, match) => acc.concat(match.players),\n        []\n    ).includes(dummyPlayer.id);\n}\nObject.freeze(hasHadBye);\nexport {hasHadBye};\n\n/**\n * @type {ScoreCalculator}\n * @returns {number[]}\n */\nfunction getPlayersByOpponent(opponentId, roundList, roundId = null) {\n    return getMatchesByPlayer(\n        opponentId,\n        roundList,\n        roundId\n    ).reduce(\n        (acc, match) => acc.concat(match.players),\n        []\n    ).filter(\n        (playerId) => playerId !== opponentId\n    );\n}\nObject.freeze(getPlayersByOpponent);\nexport {getPlayersByOpponent};\n\n/**\n * Get a list of all of a player's scores from each match.\n * @type {ScoreCalculator}\n * @returns {number[]} the list of scores\n */\nfunction playerScoreList(playerId, roundList, roundId = null) {\n    return getMatchesByPlayer(playerId, roundList, roundId).map(\n        (match) => match.result[match.players.indexOf(playerId)]\n    );\n}\n\n/**\n * TODO: Maybe merge this with the other function?\n */\n/**\n * @type {ScoreCalculator}\n * @returns {number[]}\n */\nfunction playerScoreListNoByes(playerId, roundList, roundId = null) {\n    return getMatchesByPlayer(\n        playerId,\n        roundList,\n        roundId\n    ).filter(\n        (match) => !isBye(match)\n    ).map(\n        (match) => match.result[match.players.indexOf(playerId)]\n    );\n}\n\n/**\n * @type {ScoreCalculator}\n * @returns {number}\n */\nfunction playerScore(playerId, roundList, roundId = null) {\n    let score = 0;\n    const scoreList = playerScoreList(playerId, roundList, roundId);\n    if (scoreList.length > 0) {\n        score = scoreList.reduce((a, b) => a + b);\n    }\n    return score;\n}\nObject.freeze(playerScore);\nexport {playerScore};\n\n/**\n * @type {ScoreCalculator}\n * @returns {number}\n */\nfunction playerScoreCum(playerId, roundList, roundId = null) {\n    let runningScore = 0;\n    /** @type {number[]} */\n    let cumScores = [];\n    let scores = playerScoreListNoByes(playerId, roundList, roundId);\n    scores.forEach(function (score) {\n        runningScore += score;\n        cumScores.push(runningScore);\n    });\n    let totalScore = 0;\n    if (cumScores.length !== 0) {\n        totalScore = cumScores.reduce((a, b) => a + b);\n    }\n    return totalScore;\n}\n\n/**\n * Calculate a player's color balance. A negative number means they played as\n * white more. A positive number means they played as black more.\n * @type {ScoreCalculator}\n * @returns {number}\n */\nfunction playerColorBalance(playerId, roundList, roundId = null) {\n    let color = 0;\n    getMatchesByPlayer(playerId, roundList, roundId).filter(\n        (match) => !isBye(match)\n    ).forEach(\n        function (match) {\n            if (match.players[0] === playerId) {\n                color += -1;\n            } else if (match.players[1] === playerId) {\n                color += 1;\n            }\n        }\n    );\n    return color;\n}\nObject.freeze(playerColorBalance);\nexport {playerColorBalance};\n\n/**\n * Gets the modified median factor defined in USCF § 34E1\n * @type {ScoreCalculator}\n * @param {boolean} [solkoff]\n * @returns {number}\n */\nfunction modifiedMedian(playerId, roundList, roundId = null, solkoff = false) {\n    // get all of the opponent's scores\n    let scores = getPlayersByOpponent(\n        playerId,\n        roundList,\n        roundId\n    ).filter(\n        (opponent) => opponent !== dummyPlayer.id\n    ).map(\n        (opponent) => playerScore(opponent, roundList, roundId)\n    );\n    //sort them, then remove the first and last items\n    scores.sort();\n    if (!solkoff) {\n        scores.pop();\n        scores.shift();\n    }\n    let finalScore = 0;\n    if (scores.length > 0) {\n        finalScore = scores.reduce((a, b) => a + b);\n    }\n    return finalScore;\n}\n\n/**\n * A shortcut for passing the `solkoff` variable to `modifiedMedian`.\n * @type {ScoreCalculator}\n * @returns {number}\n */\nfunction solkoff(playerId, roundList, roundId = null) {\n    return modifiedMedian(playerId, roundList, roundId, true);\n}\n\n/**\n * Get the cumulative scores of a player's opponents.\n * @type {ScoreCalculator}\n * @returns {number}\n */\nfunction playerOppScoreCum(playerId, roundList, roundId = null) {\n    const opponents = getPlayersByOpponent(\n        playerId,\n        roundList,\n        roundId\n    ).filter(\n        (opponent) => opponent !== dummyPlayer.id\n    );\n    let oppScores = opponents.map((p) => playerScoreCum(p, roundList, roundId));\n    let score = 0;\n    if (oppScores.length !== 0) {\n        score = oppScores.reduce((a, b) => a + b);\n    }\n    return score;\n}\n\nconst tbMethods = [\n    {\n        name: \"Modified median\",\n        func: modifiedMedian\n    },\n    {\n        name: \"Solkoff\",\n        func: solkoff\n    },\n    {\n        name: \"Cumulative score\",\n        func: playerScoreCum\n    },\n    {\n        name: \"Cumulative of opposition\",\n        func: playerOppScoreCum\n    },\n    {\n        name: \"Most black\",\n        func: playerColorBalance\n    }\n];\n\n/**\n * @typedef {import(\"./index\").Standing} Standing\n */\n\n/**\n * @param {Standing} standing1\n * @param {Standing} standing2\n * @returns {boolean}\n */\nfunction areScoresEqual(standing1, standing2) {\n    let areEqual = true;\n    // Check if any of them aren't equal\n    if (standing1.score !== standing2.score) {\n        areEqual = false;\n    }\n    standing1.tieBreaks.forEach(function (score) {\n        if (standing1.tieBreaks[score] !== standing2.tieBreaks[score]) {\n            areEqual = false;\n        }\n    });\n    return areEqual;\n}\n\n/**\n * @typedef {import(\"./index\").Round} Round\n */\n\n/**\n * @param {Round[]} roundList\n * @returns {number[]}\n */\nfunction getAllPlayers(roundList) {\n    const allPlayers = roundList.reduce( // flatten the rounds\n        (acc, round) => acc.concat(round),\n        []\n    ).reduce( // flaten the players\n        (acc, match) => acc.concat(match.players),\n        []\n    );\n    return Array.from(new Set(allPlayers));\n}\n\n/**\n * Sort the standings by score, see USCF tie-break rules from § 34.\n * @param {number[]} methods\n * @param {Round[]} roundList\n * @param {number} [roundId]\n * @returns {[Standing[][], string[]]} The standings and the list of method used\n */\nfunction calcStandings(methods, roundList, roundId = null) {\n    const tieBreaks = methods.map((m) => tbMethods[m]);\n    // Get a flat list of all of the players and their scores.\n    const standingsFlat = getAllPlayers(roundList).map(function (pId) {\n        /** @type {Standing} */\n        const standing = {\n            id: pId,\n            score: playerScore(pId, roundList, roundId),\n            tieBreaks: tieBreaks.map((method) => (\n                method.func(pId, roundList, roundId)\n            ))\n        };\n        return standing;\n    });\n    // Create a function to sort the players\n    let sortFunc = firstBy((standing) => standing.score, -1);\n    // For each tiebreak method, chain another `thenBy` to the function.\n    tieBreaks.forEach(function (ignore, index) {\n        sortFunc = sortFunc.thenBy((standing) => standing.tieBreaks[index], -1);\n    });\n    // Finally, sort the players.\n    standingsFlat.sort(sortFunc);\n    /** @type {Standing[][]} */\n    const standingsTree = [];\n    let runningRank = 0;\n    standingsFlat.forEach(function (standing, i, orig) {\n        if (i !== 0) { // we can't compare the first player with a previous one\n            const prevPlayer = orig[i - 1];\n            if (!areScoresEqual(standing, prevPlayer)) {\n                runningRank += 1;\n            }\n        }\n        if (!standingsTree[runningRank]) {\n            standingsTree[runningRank] = [];\n        }\n        standingsTree[runningRank].push(standing);\n    });\n    return [standingsTree, tieBreaks.map((m) => m.name)];\n}\nObject.freeze(calcStandings);\nexport {calcStandings};\n\n/**\n * TODO: merge this with the pairings one?\n * @type {ScoreCalculator}\n * @returns {Object}\n */\nfunction getPlayerMatchData(playerId, roundList, roundNum = null) {\n    return {\n        data: (playerList) => getPlayer(playerId, playerList),\n        score: () => playerScore(playerId, roundList, roundNum),\n        opponents: (playerList) => (\n            getPlayersByOpponent(playerId, roundList, roundNum).map(\n                (pId) => getPlayer(pId, playerList)\n            )\n        ),\n        colorBalance: () => playerColorBalance(playerId, roundList, roundNum),\n        avoidList: (avoidList, playerList) => (\n            getPlayerAvoidList(playerId, avoidList).map(\n                (pId) => getPlayer(pId, playerList)\n            )\n        )\n    };\n}\nObject.freeze(getPlayerMatchData);\nexport {getPlayerMatchData};","// @ts-check\nimport {firstBy} from \"thenby\";\nimport {chunk, last} from \"lodash\";\nimport blossom from \"edmonds-blossom\";\nimport {dummyPlayer, getPlayerAvoidList, getPlayer} from \"./player\";\nimport {\n    playerScore,\n    playerColorBalance,\n    getPlayersByOpponent,\n    playerMatchColor,\n    hasHadBye\n} from \"./scores\";\n/**\n * @typedef {import(\"./index\").PlayerData} PlayerData\n * @typedef {import(\"./index\").Round} Round\n * @typedef {import(\"./index\").Player} Player\n */\n/**\n * @param {number} playerId\n * @param {Round[]} roundList\n * @param {number} roundId\n * @param {Player[]} playerList\n * @param {number[][]} avoidList\n * @returns {PlayerData}\n */\nfunction genPlayerData(playerId, playerList, avoidList, roundList, roundId) {\n    /**\n     * @param {number} pId\n     * @returns {number | null}\n     */\n    const dueColor = function (pId) {\n        if (!roundList[roundId - 1]) {\n            return null;\n        }\n        let color = 0;\n        let prevColor = playerMatchColor(\n            pId,\n            roundList[roundId - 1]\n        );\n        if (prevColor === 0) {\n            color = 1;\n        }\n        return color;\n    };\n    return {\n        rating: getPlayer(playerId, playerList).rating,\n        id: playerId,\n        score: playerScore(playerId, roundList, roundId),\n        dueColor: dueColor(playerId),\n        colorBalance: playerColorBalance(playerId, roundList, roundId),\n        opponentHistory: getPlayersByOpponent(playerId, roundList, null),\n        upperHalf: false,\n        avoidList: getPlayerAvoidList(playerId, avoidList)\n    };\n}\nObject.freeze(genPlayerData);\nexport {genPlayerData};\n\n/**\n * TODO: These probably need to be tweaked a lot.\n */\n/**\n * @constant avoidMeetingTwicePriority The weight given to avoid players\n * meeting twice. This same weight is given to avoid matching players on each\n * other's \"avoid\" list. This is the highest priority. (USCF § 27A1)\n * @type {number}\n */\nconst avoidMeetingTwicePriority = 20;\n/**\n * @constant sameScoresPriority The weight given to match players with\n * equal scores. This gets muliplied against a ratio taken from the distance\n * between each player's score. For example, if the tournament has players\n * scoring 0, 1, 2, and 3, and if a player scoring 1 gets compared with a\n * player scoring 3, then their `sameScoresPriority` will be reduced by 50%.\n * (`(3 - 1) / 4 = 0.5`) (USCF § 27A2)\n * @type {number}\n */\nconst sameScoresPriority = 16;\n/**\n * @constant differentHalfPriority The weight given to match players in lower\n * versus upper halves. This is only applied to players being matched within\n * the same score group. (USCF § 27A3)\n * @type {number}\n */\nconst differentHalfPriority = 2;\n/**\n * @constant differentDueColorPriority The weight given to match players with\n * opposite due colors. (USCF § 27A4 and § 27A5)\n * @type {number}\n */\nconst differentDueColorPriority = 1;\n// /** @type {number} */\n// const maxPriority = (\n//     avoidMeetingTwicePriority\n//     + sameScoresPriority\n//     + differentHalfPriority\n//     + differentDueColorPriority\n// );\n\n\n/**\n * Create an array of blossom-compatible weighted matchups. This returns\n * an array of each potential match, formatted like so: [idOfPlayer1,\n * idOfPlayer2, priority]. A higher priority means a more likely matchup.\n * @param {PlayerData} player1\n * @param {PlayerData} player2\n * @param {number[]} scoreList\n * @returns {number}\n */\nfunction calcPairIdeal(player1, player2, scoreList) {\n    let priority = 0;\n    let scoreDiff;\n    const metBefore = player1.opponentHistory.includes(player2.id);\n    const mustAvoid = player1.avoidList.includes(player2.id);\n    if (!metBefore && !mustAvoid) {\n        priority += avoidMeetingTwicePriority;\n    }\n    // Calculate the \"distance\" between their scores and multiply that\n    // against the `sameScoresPriority` constant.\n    scoreDiff = Math.abs(\n        scoreList.indexOf(player1.score)\n        - scoreList.indexOf(player2.score)\n    );\n    scoreDiff = (scoreList.length - scoreDiff) / scoreList.length;\n    priority += sameScoresPriority * scoreDiff;\n    // Only include `differentHalfPriority` if they're in the same\n    // score group.\n    if (player1.score === player2.score) {\n        if (player1.upperHalf !== player2.upperHalf) {\n            priority += differentHalfPriority;\n        }\n    }\n    if (player1.dueColor === null) {\n        priority += differentDueColorPriority;\n    } else if (player1.dueColor !== player2.dueColor) {\n        priority += differentDueColorPriority;\n    }\n    return Math.ceil(priority);\n}\nObject.freeze(calcPairIdeal);\nexport {calcPairIdeal};\n\n/**\n * Creates pairings according to the rules specified in USCF § 27, § 28,\n * and § 29. This is a work in progress and does not account for all of the\n * rules yet.\n * @param {object[][]} roundList\n * @param {number} roundId\n * @param {number[]} players\n * @param {object[]} playerList\n * @param {number[][]} avoidList\n */\nfunction pairPlayers(players, roundId, roundList, playerList, avoidList) {\n    /** @type {number[]} */\n    let byeMatch;\n    /** @type {number[][]} */\n    let potentialMatches;\n    /** @type {Number[][]} */\n    let matches;\n    /** @type {number[]} */\n    let blossomResults;\n    /** @type {[PlayerData, PlayerData, number][]} */\n    let reducedResults;\n    /** @type {number[]} */\n    let scoreList;\n    /** @type {PlayerData[]} */\n    let playerData = players.map((playerId) => (\n        genPlayerData(playerId, playerList, avoidList, roundList, roundId)\n    ));\n    scoreList = Array.from(new Set(playerData.map((p) => p.score)));\n    scoreList.sort();\n    // Sort the data so matchups default to order by score and rating.\n    playerData.sort(\n        firstBy((p) => p.score, -1).thenBy((p) => p.rating, -1)\n    );\n    // If there's an odd number of players, time to assign a bye.\n    if (playerData.length % 2 !== 0) {\n        // Assign a bye to the lowest-rated player in the lowest score group.\n        // (USCF § 29L2.)\n        let byePlayerData = last(\n            playerData.filter( // filter out players who have had a bye already.\n                (p) => !hasHadBye(p.id, roundList, roundId)\n            )\n        );\n        // In the impossible situation that *everyone* has played a bye round\n        // previously, then just pick the last player.\n        if (!byePlayerData) {\n            byePlayerData = last(playerData);\n        }\n        byeMatch = [byePlayerData.id, dummyPlayer.id];\n        // Remove the bye'd player from the list so they won't be matched again.\n        playerData = playerData.filter((p) => p !== byePlayerData);\n    }\n    // Determine which players are in the upper and lower halves of their score\n    // groups.\n    scoreList.forEach(function (score) {\n        let playersWithScore = playerData.filter((pd) => pd.score === score);\n        playersWithScore.sort((pd) => pd.rating).reverse();\n        if (playersWithScore.length > 1) {\n            // The first chunk is the upper half\n            chunk(\n                playersWithScore,\n                playersWithScore.length / 2\n            )[0].forEach(function (playerDatum) {\n                playerDatum.upperHalf = true;\n            });\n        }\n    });\n    // Turn the data into blossom-compatible input.\n    potentialMatches = playerData.reduce(\n        function (acc, player1, ignore, src) {\n            const playerMatches = src.filter(\n                (player) => player !== player1\n            ).map(\n                (player2) => [\n                    player1.id,\n                    player2.id,\n                    calcPairIdeal(player1, player2, scoreList)\n                ]\n            );\n            return acc.concat(playerMatches);\n        },\n        []\n    );\n    // Feed all of the potential matches to Edmonds-blossom and let the\n    // algorithm work its magic. This returns an array where each index is the\n    // ID of one player and each value is the ID of the matched player.\n    blossomResults = blossom(potentialMatches);\n    // Translate those IDs into actual pairs of players.\n    reducedResults = blossomResults.reduce(\n        function (acc, p1Id, p2Id) {\n            // Filter out unmatched players. Even though we removed the byes\n            // from the list, blossom will automatically include their missing\n            // IDs in its results.\n            if (p1Id !== -1) {\n                const p1 = playerData.filter((p) => p.id === p1Id)[0];\n                const p2 = playerData.filter((p) => p.id === p2Id)[0];\n                const ideal = potentialMatches.filter(\n                    (pair) => pair[0] === p1Id && pair[1] === p2Id\n                )[0][2];\n                const matched = acc.map((pair) => pair[0]);\n                // Blossom returns a lot of redundant matches. Check that this\n                // matchup wasn't already added.\n                if (!matched.includes(p1) && !matched.includes(p2)) {\n                    acc.push([p1, p2, ideal]);\n                }\n            }\n            return acc;\n        },\n        []\n    );\n    // Sort by net score and rating for board placement.\n    reducedResults.sort(\n        firstBy(\n            /** @param {[PlayerData, PlayerData, number]} pair */\n            (pair) => pair[0].score + pair[1].score,\n            -1\n        ).thenBy(\n            /** @param {[PlayerData, PlayerData, number]} pair */\n            (pair) => pair[0].rating + pair[1].rating,\n            -1\n        )\n    );\n    // Turn the results into new match objects.\n    matches = reducedResults.map(\n        function (pair) {\n            const player1 = pair[0];\n            const player2 = pair[1];\n            // const ideal = pair[2];\n            const match = [player1.id, player2.id];\n            if (player1.colorBalance < player2.colorBalance) {\n                match.reverse();\n            }\n            return match;\n        }\n    );\n    // The bye match always gets added last so as not to affect the numbering.\n    if (byeMatch) {\n        matches.push(byeMatch);\n    }\n    return matches;\n}\n\nexport default Object.freeze(pairPlayers);","// @ts-check\n/**\n * @typedef {import(\"./index\").Match} Match\n */\n/**\n *\n * @param {object} importObj\n */\nfunction createMatch(importObj) {\n    /** @type {Match} */\n    const match = {\n        players: importObj.players,\n        result: [0, 0],\n        origRating: importObj.origRating,\n        newRating: importObj.newRating\n    };\n    return match;\n}\nexport default Object.freeze(createMatch);\n","// @ts-check\nimport React, {Fragment, useState} from \"react\";\nimport numeral from \"numeral\";\nimport {Tabs, TabList, Tab, TabPanels, TabPanel} from \"@reach/tabs\";\nimport {OpenButton, PanelContainer, Panel, BackButton} from \"./utility\";\nimport {getPlayer, calcNewRatings} from \"../chess-tourney/player\";\nimport {calcStandings, getPlayerMatchData} from \"../chess-tourney/scores\";\nimport pairPlayers from \"../chess-tourney/pairing\";\nimport createMatch from \"../chess-tourney/match\";\nimport {BLACK, WHITE} from \"../chess-tourney/constants\";\n\n\nexport function TournamentList({\n    playerList,\n    setPlayerList,\n    avoidList,\n    tourneyList,\n    setTourneyList\n}) {\n    const [openTourney, setOpenTourney] = useState(null);\n    let content = <Fragment></Fragment>;\n    if (openTourney !== null) {\n        content = (\n            <TournamentTabs\n                tourneyId={openTourney}\n                playerList={playerList}\n                setOpenTourney={setOpenTourney}\n                backButton={<BackButton action={() => setOpenTourney(null)}/>}\n                avoidList={avoidList}\n                setPlayerList={setPlayerList}\n                tourneyList={tourneyList}\n                setTourneyList={setTourneyList} />\n        );\n    } else {\n        content = (\n            <nav>\n            {(\n                (tourneyList.length > 0)\n                ?\n                    <ol>\n                    {tourneyList.map((tourney, i) =>\n                        <li key={i}>\n                            <button onClick={() => setOpenTourney(i)}>\n                                {tourney.name}\n                            </button>\n                        </li>\n                    )}\n                    </ol>\n                :\n                    <p>\n                        No tournaments added yet.\n                    </p>\n            )}\n            </nav>\n        );\n    }\n    return (\n        <div>\n            {content}\n        </div>\n    );\n}\n\n/**\n *\n * @param {Object} props\n */\nexport function TournamentTabs({\n    tourneyId,\n    playerList,\n    setPlayerList,\n    backButton,\n    avoidList,\n    tourneyList,\n    setTourneyList\n}) {\n    const tourney = tourneyList[tourneyId];\n    const players = tourney.players;\n    const [defaultTab, setDefaultTab] = useState(0);\n    const [standingTree, tbMethods] = calcStandings(\n        tourney.tieBreaks,\n        tourney.roundList\n    );\n    function newRound() {\n        const round = [];\n        tourney.roundList = tourney.roundList.concat([round]);\n        setTourneyList([...tourneyList]);\n        setDefaultTab(tourney.roundList.length + 1);\n    }\n    function autoPair(unPairedPlayers, roundId) {\n        const pairs = pairPlayers(\n            unPairedPlayers,\n            roundId,\n            tourney.roundList,\n            playerList,\n            avoidList\n        );\n        const matchList = pairs.map(\n            (pair) => createMatch({\n                players: [pair[WHITE], pair[BLACK]],\n                origRating: [\n                    getPlayer(pair[WHITE], playerList).rating,\n                    getPlayer(pair[BLACK], playerList).rating\n                ],\n                newRating: [\n                    getPlayer(pair[WHITE], playerList).rating,\n                    getPlayer(pair[BLACK], playerList).rating\n                ]\n            })\n        );\n        tourney.roundList[roundId] = (\n            tourney.roundList[roundId].concat(matchList)\n        );\n        setTourneyList([...tourneyList]);\n    }\n    function manualPair(pair, roundId) {\n        const match = createMatch({\n            players: [pair[WHITE], pair[BLACK]],\n            origRating: [\n                getPlayer(pair[WHITE], playerList).rating,\n                getPlayer(pair[BLACK], playerList).rating\n            ],\n            newRating: [\n                getPlayer(pair[WHITE], playerList).rating,\n                getPlayer(pair[BLACK], playerList).rating\n            ]\n        });\n        tourney.roundList[roundId].push(match);\n        setTourneyList([...tourneyList]);\n    }\n    function setMatchResult(roundId, matchId, result) {\n        const match = tourney.roundList[roundId][matchId];\n        const white = getPlayer(match.players[WHITE], playerList);\n        const black = getPlayer(match.players[BLACK], playerList);\n        const [\n            whiteRating,\n            blackRating\n        ] = calcNewRatings(\n            match.origRating,\n            [white.matchCount, black.matchCount],\n            result\n        );\n        setTourneyList(function (prevTourney) {\n            const newTourney = [...prevTourney];\n            newTourney[tourneyId].roundList[roundId][matchId].result = result;\n            newTourney[tourneyId].roundList[roundId][matchId].newRating = [\n                whiteRating,\n                blackRating\n            ];\n            return newTourney;\n        });\n        white.rating = whiteRating;\n        black.rating = blackRating;\n        white.matchCount += 1;\n        black.matchCount += 1;\n        setPlayerList([...playerList]);\n    }\n    return (\n        <Tabs defaultIndex={defaultTab}>\n            {backButton}\n            <h2>{tourney.name}</h2>\n            <TabList>\n                <Tab>Players</Tab>\n                <Tab>Scores</Tab>\n                {tourney.roundList.map((round, id) =>\n                    <Tab key={id}>Round {id + 1}</Tab>\n                )}\n            </TabList>\n            <TabPanels>\n            <TabPanel>\n                <ul>\n                {players.map((pId) =>\n                    <li key={pId}>\n                        {getPlayer(pId, playerList).firstName}&nbsp;\n                        {getPlayer(pId, playerList).lastName}\n                    </li>\n                )}\n                </ul>\n            </TabPanel>\n            <TabPanel>\n                    <table>\n                        <thead>\n                            <tr>\n                                <th>#</th>\n                                <th>Name</th>\n                                <th>Score</th>\n                                {tbMethods.map((name, i) =>\n                                    <th key={i}>{name}</th>\n                                )}\n                            </tr>\n                        </thead>\n                        <tbody>\n                        {standingTree.map((standings, rank) =>\n                            standings.map((standing) =>\n                                <tr key={standing.id}>\n                                    <td className=\"table__number\">\n                                        {rank + 1}\n                                    </td>\n                                    <td>\n                                        {getPlayer(\n                                            standing.id,\n                                            playerList\n                                        ).firstName}\n                                    </td>\n                                    <td className=\"table__number\">\n                                        {standing.score}\n                                    </td>\n                                    {standing.tieBreaks.map((score, i) =>\n                                        <td key={i} className=\"table__number\">\n                                            {score}\n                                        </td>\n                                    )}\n                                </tr>\n                            )\n                        )}\n                        </tbody>\n                    </table>\n            </TabPanel>\n            {tourney.roundList.map((matchList, id) =>\n                <TabPanel key={id}>\n                    <Round\n                        matchList={matchList}\n                        num={id}\n                        tourney={tourney}\n                        playerList={playerList}\n                        setMatchResult={setMatchResult}\n                        autoPair={autoPair}\n                        manualPair={manualPair}/>\n                </TabPanel>\n            )}\n            </TabPanels>\n            <button onClick={() => newRound()}>New Round</button>\n        </Tabs>\n    );\n}\n\nfunction Round({\n    matchList,\n    tourney,\n    num,\n    playerList,\n    setMatchResult,\n    autoPair,\n    manualPair\n}) {\n    const [selectedMatch, setSelectedMatch] = useState(null);\n    const [selectedPlayers, setSelectedPlayers] = useState([]);\n    function selectPlayer(event) {\n        const pId = Number(event.target.value);\n        if (event.target.checked) {\n            setSelectedPlayers(function (prevState) {\n                // stop React from adding an ID twice in a row\n                if (!prevState.includes(pId)) {\n                    prevState.push(pId);\n                }\n                // ensure that only the last two players stay selected.\n                return prevState.slice(-2);\n            });\n        } else {\n            setSelectedPlayers(selectedPlayers.filter((id) => id !== pId));\n        }\n    }\n    const roundList = tourney.roundList;\n    const matched = matchList.reduce(\n        (acc, match) => acc.concat(match.players),\n        []\n    );\n    const unMatched = tourney.players.filter(\n        (pId) => !matched.includes(pId)\n    );\n    return (\n        <PanelContainer>\n            <Panel>\n            <table className=\"table__roster\">\n                <caption>Round {num + 1} results</caption>\n                <thead>\n                <tr>\n                    <th className=\"row__id\">#</th>\n                    <th className=\"row__player\">White</th>\n                    <th className=\"row__result\">Result</th>\n                    <th className=\"row__player\">Black</th>\n                    <th className=\"row__controls\"></th>\n                </tr>\n                </thead>\n                <tbody>\n                {matchList.map((match, pos) =>\n                    <tr key={pos}>\n                        <td className=\"table__number row__id\">{pos + 1}</td>\n                        <td className=\"table__player row__player\">\n                            {getPlayer(match.players[0], playerList).firstName}\n                            &nbsp;\n                            {getPlayer(match.players[0], playerList).lastName}\n                        </td>\n                        <td className=\"data__input row__result\">\n                            <input\n                                type=\"radio\"\n                                checked={match.result[0] === 1}\n                                onChange={\n                                    () => setMatchResult(num, pos, [1, 0])\n                                }/>\n                            <input\n                                type=\"radio\"\n                                checked={match.result[0] === 0.5}\n                                onChange={\n                                    () => setMatchResult(num, pos, [0.5, 0.5])\n                                }/>\n                            <input\n                                type=\"radio\"\n                                checked={match.result[1] === 1}\n                                onChange={\n                                    () => setMatchResult(num, pos, [0, 1])\n                                }/>\n                        </td>\n                        <td className=\"table__player row__player\">\n                            {getPlayer(match.players[1], playerList).firstName}\n                            &nbsp;\n                            {getPlayer(match.players[1], playerList).lastName}\n                        </td>\n                        <td className=\"data__input row__controls\">\n                        {(\n                        (selectedMatch !== pos)\n                        ? <OpenButton action={() => setSelectedMatch(pos)} />\n                        : <BackButton action={() => setSelectedMatch(null)} />\n                        )}\n                        </td>\n                    </tr>\n                )}\n                </tbody>\n            </table>\n            </Panel>\n            <Panel>\n            {selectedMatch !== null &&\n                <div>\n                    <h2>Match info</h2>\n                    <PlayerMatchInfo\n                        match={matchList[selectedMatch]}\n                        color={0}\n                        playerData={getPlayerMatchData(\n                            matchList[selectedMatch].players[0],\n                            roundList,\n                            num\n                        )}\n                        playerList={playerList}/>\n                    <PlayerMatchInfo\n                        match={matchList[selectedMatch]}\n                        color={1}\n                        playerData={getPlayerMatchData(\n                            matchList[selectedMatch].players[1],\n                            roundList,\n                            num\n                        )}\n                        playerList={playerList} />\n                </div>\n            }\n            {unMatched.length > 0 && (\n                <Fragment>\n                    <h3>Unmatched players</h3>\n                    <ul>\n                        {unMatched.map((pId) =>\n                            <li key={pId}>\n                                <input\n                                    type=\"checkbox\"\n                                    checked={selectedPlayers.includes(pId)}\n                                    value={pId}\n                                    onChange={selectPlayer}/>\n                                {getPlayer(pId, playerList).firstName}\n                            </li>\n                        )}\n                    </ul>\n                    <button\n                        onClick={() => manualPair(selectedPlayers, num)}\n                        disabled={selectedPlayers.length !== 2}>\n                        Pair checked\n                    </button>&nbsp;\n                    <button\n                        onClick={() => autoPair(unMatched, num)}\n                        disabled={unMatched.length === 0}>\n                        Auto-pair\n                    </button>\n                </Fragment>\n            )}\n            </Panel>\n        </PanelContainer>\n    );\n}\n\nfunction PlayerMatchInfo({match, color, playerData, playerList}) {\n    const colorBalance = playerData.colorBalance();\n    let prettyBalance = \"Even\";\n    if (colorBalance < 0) {\n        prettyBalance = \"White +\" + Math.abs(colorBalance);\n    } else if (colorBalance > 0) {\n        prettyBalance = \"Black +\" + colorBalance;\n    }\n    return (\n        <dl className=\"player-card\">\n            <h3>\n                {playerData.data(playerList).firstName}&nbsp;\n                {playerData.data(playerList).lastName}\n            </h3>\n            <dt>Score</dt>\n            <dd>{playerData.score()}</dd>\n            <dt>Rating</dt>\n            <dd>\n                {match.origRating[color]}\n                &nbsp;\n                (\n                {numeral(\n                    match.origRating[color] - match.newRating[color]\n                ).format(\"+0\")}\n                )\n            </dd>\n            <dt>Color balance</dt>\n            <dd>{prettyBalance}</dd>\n            <dt>Opponent history</dt>\n            <dd>\n                <ol>\n                {playerData.opponents(playerList).map((opponent) =>\n                    <li key={opponent.id}>\n                    {opponent.firstName}\n                    </li>\n                )}\n                </ol>\n            </dd>\n            <dt>Players to avoid</dt>\n        </dl>\n    );\n}\n","// @ts-check\nimport React, {useState, useEffect, Fragment} from \"react\";\nimport {BackButton, OpenButton} from \"./utility\";\nimport createPlayer, {\n    getPlayer,\n    getPlayerAvoidList,\n    kFactor\n} from \"../chess-tourney/player\";\n\n/**\n * @param {Object} props\n */\nexport function PlayerView({\n    playerList,\n    setPlayerList,\n    avoidList,\n    setAvoidList\n}) {\n    /** @type {number} */\n    const defaultOpen = null;\n    const [openPlayer, setOpenPlayer] = useState(defaultOpen);\n    if (openPlayer !== null) {\n        return <PlayerInfoBox\n            key={openPlayer}\n            playerId={openPlayer}\n            setOpenPlayer={setOpenPlayer}\n            playerList={playerList}\n            avoidList={avoidList}\n            setAvoidList={setAvoidList} />;\n    } else {\n        return <PlayerList\n            playerList={playerList}\n            setPlayerList={setPlayerList}\n            setOpenPlayer={setOpenPlayer}/>;\n    }\n}\n\n/**\n * @param {Object} props\n */\nexport function PlayerList({\n    playerList,\n    setPlayerList,\n    setOpenPlayer\n}) {\n    const newPlayerDefault = {firstName: \"\", lastName: \"\", rating: 1200};\n    const [newPlayerData, setNewPlayerdata] = useState(newPlayerDefault);\n    const ids = playerList.map((p) => p.id);\n    ids.sort((a, b) => a - b);\n    ids.reverse();\n    const [nextId, setNextId] = useState(ids[0] + 1);\n    const handleSubmit = function (event) {\n        event.preventDefault();\n        const newPlayer = createPlayer(newPlayerData);\n        newPlayer.id = nextId;\n        setNextId((prevId) => prevId + 1);\n        setNewPlayerdata(newPlayerDefault);\n        setPlayerList(playerList.concat(newPlayer));\n    };\n    const updateField = function (event) {\n        event.preventDefault();\n        /** @type {Object<string, string>} */\n        let update = {};\n        update[event.currentTarget.name] = event.currentTarget.value;\n        setNewPlayerdata(Object.assign({}, newPlayerData, update));\n    };\n    const delPlayer = function (event, player) {\n        event.preventDefault();\n        const index = playerList.indexOf(player);\n        playerList.splice(index, 1);\n        setPlayerList([...playerList]);\n    };\n    let rosterTable = <Fragment></Fragment>;\n    if (playerList.length > 0) {\n        rosterTable =\n        <table>\n            <caption>Demo Roster</caption>\n            <thead>\n                <tr>\n                    <th>First name</th>\n                    <th>Last name</th>\n                    <th>Rating</th>\n                    <th></th>\n                    <th></th>\n                </tr>\n            </thead>\n            <tbody>\n            {playerList.map((player) =>\n                <tr key={player.id}>\n                    <td className=\"table__player\">{player.firstName}</td>\n                    <td className=\"table__player\">{player.lastName}</td>\n                    <td className=\"table__number\">{player.rating}</td>\n                    <td>\n                        <button\n                            onClick={(event) =>\n                                delPlayer(event, player)\n                            }>\n                            x\n                        </button>\n                    </td>\n                    <td>\n                        <OpenButton action={() => setOpenPlayer(player.id)} />\n                    </td>\n                </tr>\n                )}\n            </tbody>\n        </table>;\n    }\n    return (\n        <div className=\"roster\">\n            {rosterTable}\n            <form onSubmit={handleSubmit}>\n            <fieldset>\n                <legend>Add your own players</legend>\n                <p>\n                    <label>\n                        First name&nbsp;\n                        <input type=\"text\" name=\"firstName\"\n                            onChange={updateField}\n                            value={newPlayerData.firstName} required />\n                    </label>\n                </p>\n                <p>\n                    <label>\n                        Last name&nbsp;\n                        <input type=\"text\" name=\"lastName\"\n                            onChange={updateField}\n                            value={newPlayerData.lastName} required />\n                    </label>\n                </p>\n                <p>\n                    <label>\n                        Rating&nbsp;\n                        <input type=\"number\" name=\"rating\"\n                            onChange={updateField}\n                            value={newPlayerData.rating} required />\n                    </label>\n                </p>\n                <p>\n                    <input type=\"submit\" value=\"Add\"/>\n                </p>\n            </fieldset>\n            </form>\n        </div>\n    );\n}\n\n/**\n *\n * @param {Object} props\n */\nfunction PlayerInfoBox({\n    playerId,\n    playerList,\n    setOpenPlayer,\n    avoidList,\n    setAvoidList\n}) {\n    const [singAvoidList, setSingAvoidList] = useState(\n        getPlayerAvoidList(playerId, avoidList)\n    );\n    const unAvoided = () => playerList.map(\n        (player) => player.id\n    ).filter(\n        (pId) => !singAvoidList.includes(pId) && pId !== playerId\n    );\n    const [selectedAvoider, setSelectedAvoider] = useState(unAvoided()[0]);\n    function avoidAdd(event) {\n        event.preventDefault();\n        avoidList.push([playerId, Number(selectedAvoider)]);\n        setAvoidList([...avoidList]);\n    };\n    /** @param {number} avoidPlayer */\n    function avoidRemove(avoidPlayer) {\n        setAvoidList(avoidList.filter(\n            (pair) => !(pair.includes(playerId) && pair.includes(avoidPlayer))\n        ));\n    };\n    useEffect(function () {\n        setSelectedAvoider(unAvoided()[0]);\n        setSingAvoidList(getPlayerAvoidList(playerId, avoidList));\n    }, [avoidList]);\n    return (\n        <div>\n            <BackButton action={() => setOpenPlayer(null)}/>\n            <h2>\n                {getPlayer(playerId, playerList).firstName}&nbsp;\n                {getPlayer(playerId, playerList).lastName}\n            </h2>\n            <dl>\n                <dt>Matches played</dt>\n                <dd>{getPlayer(playerId, playerList).matchCount}</dd>\n                <dt>K factor</dt>\n                <dd>{kFactor(getPlayer(playerId, playerList).matchCount)}</dd>\n                <dt>Players to avoid</dt>\n                <dd>\n                    <ul>\n                    {singAvoidList.map((pId) =>\n                        <li key={pId}>\n                            {getPlayer(pId, playerList).firstName}&nbsp;\n                            {getPlayer(pId, playerList).lastName}\n                            <button onClick={() => avoidRemove(pId)}>\n                                x\n                            </button>\n                        </li>\n                    )}\n                    {(avoidList.length === 0) &&\n                        <li>None</li>\n                    }\n                    </ul>\n                </dd>\n            </dl>\n            <form onSubmit={(event) => avoidAdd(event)}>\n            <fieldset>\n                <legend>Add player to avoid</legend>\n                <select\n                    onBlur={(event) => setSelectedAvoider(event.target.value)}>\n                {unAvoided().map((pId) =>\n                    <option key={pId} value={pId}>\n                        {getPlayer(pId, playerList).firstName}&nbsp;\n                        {getPlayer(pId, playerList).lastName}\n                    </option>\n                )}\n                </select>\n                <input type=\"submit\" value=\"Add\"/>\n            </fieldset>\n            </form>\n        </div>\n    );\n}\n","// @ts-check\nimport React, {useState} from \"react\";\nexport function Options({\n    playerList,\n    avoidList,\n    tourneyList,\n}) {\n    const [outputPlayers, setOutputPlayers] = useState(\n        JSON.stringify(playerList, null, 2)\n    );\n    const [outputTourney, setOutputTourney] = useState(\n        JSON.stringify(tourneyList, null, 2)\n    );\n    return (\n        <section>\n            <h2>Export tournament data</h2>\n            <form onSubmit={(event) => event.preventDefault()}>\n                <textarea\n                    className=\"json\"\n                    rows={25}\n                    cols={50}\n                    value={outputTourney}\n                    onChange={(event) => setOutputTourney(event.target.value)}\n                    name=\"tourneyData\"\n                    />\n                <input type=\"submit\" value=\"load\" disabled />\n            </form>\n            <h2>Export player data</h2>\n            <form onSubmit={(event) => event.preventDefault()}>\n                <textarea\n                    className=\"json\"\n                    rows={25}\n                    cols={50}\n                    value={outputPlayers}\n                    name=\"playerdata\"\n                    onChange={(event) => setOutputPlayers(event.target.value)}\n                />\n                <input type=\"submit\" value=\"Load\" disabled />\n            </form>\n        </section>\n    );\n}","// @ts-check\nimport React, { useState, useEffect } from \"react\";\nimport \"./App.css\";\nimport { Tabs, TabList, Tab, TabPanels, TabPanel } from \"@reach/tabs\";\nimport \"@reach/tabs/styles.css\";\nimport demoRoster from \"./demo-players.json\";\nimport demoTourneyList from \"./demo-tourney.json\";\nimport createPlayer from \"./chess-tourney/player\";\nimport {cleanAvoidList} from \"./chess-tourney/player\";\nimport {TournamentList} from \"./jsx/tournament\";\nimport {PlayerView} from \"./jsx/players.jsx\";\nimport {Options} from \"./jsx/options\";\n\nfunction App() {\n    const [playerList, setPlayerList] = useState(\n        demoRoster.playerList.map((p) => createPlayer(p))\n    );\n    const [avoidList, setAvoidList] = useState(demoRoster.avoidList);\n    const [tourneyList, setTourneyList] = useState(demoTourneyList);\n    useEffect(function () {\n        // remove stale IDs\n        setAvoidList(cleanAvoidList(avoidList, playerList));\n    }, [playerList]);\n    return (\n        <React.StrictMode>\n        <Tabs className=\"app\" defaultIndex={1}>\n            <TabList className=\"header\">\n                <Tab>Players</Tab>\n                <Tab>Tournament</Tab>\n                <Tab>Options</Tab>\n                <Tab>About</Tab>\n            </TabList>\n            <TabPanels className=\"body\">\n                <TabPanel>\n                    <PlayerView\n                        playerList={playerList}\n                        setPlayerList={setPlayerList}\n                        avoidList={avoidList}\n                        setAvoidList={setAvoidList}/>\n                </TabPanel>\n                <TabPanel>\n                    <TournamentList\n                        playerList={playerList}\n                        setPlayerList={setPlayerList}\n                        avoidList={avoidList}\n                        tourneyList={tourneyList}\n                        setTourneyList={setTourneyList}/>\n                </TabPanel>\n                <TabPanel>\n                    <Options\n                        playerList={playerList}\n                        avoidList={avoidList}\n                        tourneyList={tourneyList}\n                    />\n                </TabPanel>\n                <TabPanel>\n                    <p>\n                        Coming soon.\n                    </p>\n                </TabPanel>\n            </TabPanels>\n            <footer className=\"caution footer\">\n                <Caution />\n            </footer>\n        </Tabs>\n        </React.StrictMode>\n    );\n}\n\nexport const RedTab = (props) => <Tab {...props} style={{ color: \"red\" }} />;\n\nfunction Caution() {\n    return (\n        <p>\n            <span role=\"img\" aria-label=\"waving hand\">👋</span>&nbsp;\n            This is an unstable demo build!\n            Want to help make it better? Head to the&nbsp;\n            <span role=\"img\" aria-label=\"finger pointing right\">👉</span>&nbsp;\n            <a href=\"https://github.com/johnridesabike/chessahoochee\">\n                Git repository\n            </a>.\n        </p>\n    );\n}\n\nexport {App, Caution};\n","/*jslint browser*/\n/*global process fetch*/\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets;\n      // see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport {App} from \"./App.jsx\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}